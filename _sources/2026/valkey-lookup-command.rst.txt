Valkey源码剖析（12）：查找命令
==============================

前面的文章介绍了Valkey服务器如何通过\ ``populateCommandTable()``\ 函数构建起将命令名映射至命令结构的命令表。下面来看看，在客户端向服务器发送命令请求的时候，Valkey服务器是如何根据请求查找对应命令的。

当Valkey服务器接收到客户端发送的命令请求之后，它会对请求进行解析，然后将请求想要执行的命令及其参数以\ ``server.h/robj``\ 数组的方式存储起来。比如说，当Valkey服务器接收到客户端发送的以下命令时：

.. code:: bash

   SET msg "hello"

服务器将创建一个包含三个\ ``robj``\ 对象的数组，它们分别存储着\ ``"SET"``\ 、\ ``"msg"``\ 、和\ ``"hello"``\ 三个字符串，其中第一个字符串为命令，而后面两个字符串则为参数。

之后，服务器会调用\ ``server.c/lookupCommand()``\ 函数，并将\ ``robj``\ 指针类型的数组\ ``argv``\ 以及数组的长度\ ``argv``\ 传递给该函数以查找命令对应的命令结构：

.. code:: c

   struct serverCommand *lookupCommand(robj **argv, int argc) {
       return lookupCommandLogic(server.commands, argv, argc, 0);
   }

   struct serverCommand *lookupCommandLogic(hashtable *commands, robj **argv, int argc, int strict) {
       void *entry = NULL;
       // 查找命令并回报结果
       bool found_command = hashtableFind(commands, argv[0]->ptr, &entry);
       struct serverCommand *base_cmd = entry;
       bool has_subcommands = found_command && base_cmd->subcommands_ht;
       if (argc == 1 || !has_subcommands) {
           if (strict && argc != 1) return NULL;
           /* Note: It is possible that base_cmd->proc==NULL (e.g. CONFIG) */
           // 返回找到的命令实现函数
           return base_cmd;
       } else { /* argc > 1 && has_subcommands */
           if (strict && argc != 2) return NULL;
           /* Note: Currently we support just one level of subcommands */
           // 按需进一步查找子命令
           return lookupSubcommand(base_cmd, argv[1]->ptr);
       }
   }

从上面展示的代码可以看到，\ ``lookupSubcommand()``\ 函数将调用\ ``server.c/lookupCommandLogic()``\ 函数，而后者会继续调用\ ``hashtable.c/hashtableFind()``\ 函数，并根据给定的命令名，从传入的命令表\ ``server.commands``\ 中查找与给定命令名对应的命令结构：

-  如果找到了对应的命令结构，那么返回它；

-  如果传入的命令还包含子命令，那么调用\ ``server.c/lookupSubcommand()``\ 函数进一步查找子命令对应的命令结构；

-  最后，如果未能找到对应的命令结构，那么返回\ ``NULL``\ 。

在找到对应的命令结构之后，服务器接下来就要执行被请求的命令了，具体的流程将在下一篇文章中进行介绍。

| 黄健宏
| 2026.1.4
